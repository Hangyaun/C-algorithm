1、好的算法

符合语法，能够编译、链接 

能够正确处理简单的输入 

能够正确处理大规模的输入 

能够正确处理一般性的输入 

能够正确处理退化的输入 

能够正确处理任意合法的输入 

健壮： 能辨别不合法的输入并做适当处理 

而不致非正常退出 

v 可读： 结构化 + 准确命名 + 注释 + ... 

v 效率： 速度尽可能快 

存储空间尽可能少

 

P49 那几个基本算法和递归要搞清楚

A) 尾递归      B）线性递归      C）二分递归     D）多分支递归

这些术语描述了递归算法中的不同类型，主要是基于递归调用的结构和问题的分解方式。下面是它们的详细解释：

 

\###  A) 尾递归 (Tail Recursion)

尾递归是指**递归调用出现在函数的最后一步**，即递归调用之后没有其他操作。尾递归有一个很大的优点，就是在某些编程语言中，编译器可以进行**尾递归优化**，将递归转换为迭代，从而节省栈空间。

 

**示例**：计算阶乘的尾递归版本

\```python

def tail_factorial(n, acc=1):

  if n == 0:

​    return acc

  else:

​    return tail_factorial(n-1, n * acc)

\```

在这个例子中，递归调用 `tail_factorial(n-1, n * acc)` 是最后一步，没有其他操作跟随。

 

\### B) 线性递归 (Linear Recursion)

线性递归是指**每次递归调用只进行一次递归调用**，且问题被线性地简化，通常每次递归只减少一个规模，直至达到基准情况。递归调用的层级是线性的。

 

**示例**：计算阶乘的线性递归版本

\```python

def factorial(n):

  if n == 0:

​    return 1

  else:

​    return n * factorial(n - 1)

\```

在这个例子中，每次递归调用只减少 \( n \) 的值，直到到达基准情况。

 

\### C) 二分递归 (Binary Recursion)

二分递归是指每次递归调用时**进行两次递归调用**，即每个问题被分成两个子问题。这种递归常用于分治法，如归并排序和二分查找。

 

**示例**：计算斐波那契数列的二分递归版本

\```python

def fibonacci(n):

  if n == 0:

​    return 0

  elif n == 1:

​    return 1

  else:

​    return fibonacci(n-1) + fibonacci(n-2)

\```

在这个例子中，每次递归调用会产生两个子递归调用。

 

\### D) 多分支递归 (Multiple Recursion)

多分支递归是指每次递归调用中**会产生多个（两个以上）递归调用**，即问题可以分解为多个子问题。这种递归比二分递归更复杂，每次分解的子问题可能超过两个。

 

**示例**：解决多叉树遍历问题

\```python

def traverse(tree):

  if tree is None:

​    return

  for child in tree.children:

​    traverse(child)

\```

在这个例子中，树的每个节点可以有多个子节点，每个子节点都需要递归处理。

 

\### 总结：

\- **尾递归**：递归调用是函数的最后一步，具有优化潜力。

\- **线性递归**：每次递归调用只产生一个递归调用，问题规模线性减少。

\- **二分递归**：每次递归调用产生两个子问题，典型的二分法问题。

\- **多分支递归**：每次递归调用产生多个子问题，通常用于处理更复杂的结构。 

 

这四种递归类型在不同场景下有不同的应用，选择合适的递归方式可以显著影响算法的效率和复杂度。

 

2、算法思想

迭代与递归：减而治之

为求解一个大规模的问题，可以 

\- 将其划分为两个子问题：其一平凡，另一规模缩减 //单调性 

\- 分别求解子问题；再由子问题的解，得到原问题的解 

 

迭代与递归：分而治之

空间复杂度：看递归调用栈的深度

 

 

时间复杂度

大O的意思是小于等于，小o才是反过来，中间那个阶数等

Master Theorem （主定理）

![img](file:///C:\Users\张航\AppData\Local\Temp\ksohtml5284\wps1.jpg) 

把![img](file:///C:\Users\张航\AppData\Local\Temp\ksohtml5284\wps2.png)与g（N）做对比，g如果大按照g的来，否则按照前者

 

 

若相等

![img](file:///C:\Users\张航\AppData\Local\Temp\ksohtml5284\wps3.jpg) 

二分查找，归并排序（合并 的时候需要对于每个元素进行操作，两个有序向量/列表的合并

![img](file:///C:\Users\张航\AppData\Local\Temp\ksohtml5284\wps4.jpg) 



相等特殊情况+每一种计算对应的算法

情况三证明 

利用幂方级数求和，使得次数加一

特例出现k需要不等于-1，因为求和之后是加一次，但是负一次求和是log级数

 

 

空间复杂度

首先，何谓“空间复杂度”？ 

\- 除却输入数据，算法 

在执行过程中所使用的空间量 

\- 重复使用者，只计一次 

\- 通常不超过时间复杂度

对于大规模的问题、复杂的递归算法，递归跟踪不再适用 

此时可采用另一抽象的方法... 

v从递推的角度看，为求解规模为n的问题sum(A, n)，需 

//T(n) 

\- 递归求解规模为n-1的问题sum(A, n-1)，再 

//T(n-1) 

\- 累加上A[n-1] //O(1) 

 

递推方程 t（n）=t(n-1)+O（1）

 

 

 

# 向量

 ![image-20240912124543960](C:\Users\张航\AppData\Roaming\Typora\typora-user-images\image-20240912124543960.png)



**template** **<****typename T**> class** **Vector** **{** //向量模板类

**private: Rank _size; Rank _capacity;** **T***** _elem;** //规模、容量、数据区

**protected:**

/* ... 内部函数 */

**public:**

/* ... 构造函数 */

/* ... 析构函数 */

/* ... 只读接口 */ 

/* ... 可写接口 */

/* ... 遍历接口 */

**};**



